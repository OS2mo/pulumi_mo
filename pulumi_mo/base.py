# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from abc import ABC
from abc import abstractmethod
from collections.abc import Callable
from typing import Any
from uuid import UUID

from authlib.integrations.httpx_client import OAuth2Client
from more_itertools import only
from pulumi import Config
from pulumi.dynamic import ConfigureRequest
from pulumi.dynamic import CreateResult
from pulumi.dynamic import ReadResult
from pulumi.dynamic import ResourceProvider
from pulumi.dynamic import UpdateResult
from pulumi.dynamic.config import Config as DynamicConfig
from pydantic import BaseModel
from pydantic import parse_obj_as

from .autogenerated_graphql_client.client import GraphQLClient

DEFAULT_VALIDITY = {"from": "1970-01-01T00:00:00Z"}


def create_graphql_client(
    mora_base: str, client_id: str, client_secret: str, auth_server: str | None = None
) -> GraphQLClient:
    auth_server = auth_server or (mora_base + "/auth/")
    auth_realm = "mo"
    timeout = 60
    graphql_version = 25

    oauth_client = OAuth2Client(
        base_url=mora_base,
        client_id=client_id,
        client_secret=client_secret,
        grant_type="client_credentials",
        # TODO: We should take a full token URL instead of hard-coding Keycloak's
        # URL scheme. Let's wait until the legacy clients are removed.
        token_endpoint=f"{auth_server}/realms/{auth_realm}/protocol/openid-connect/token",
        # TODO (https://github.com/lepture/authlib/issues/531): Hack to enable
        # automatic fetching of token on first call, instead of only refreshing.
        token={"expires_at": -1, "access_token": ""},
        timeout=timeout,
    )
    graphql_client = GraphQLClient(
        url=f"{mora_base}/graphql/v{graphql_version}", http_client=oauth_client
    )
    return graphql_client


def create_graphql_client_from_config(config: Config | DynamicConfig) -> GraphQLClient:
    mora_base = config.require("mora_base")
    client_id = config.require("mora_client_id")
    client_secret = config.require("mora_client_secret")
    auth_server = config.get("mora_auth_server")
    return create_graphql_client(mora_base, client_id, client_secret, auth_server)


class MOGraphQLProvider(ResourceProvider):
    session: GraphQLClient

    def configure(self, req: ConfigureRequest) -> None:
        graphql_client = create_graphql_client_from_config(req.config)
        session = graphql_client.__enter__()
        self.session = session

    def __del__(self) -> None:
        if hasattr(self, "session") and self.session:
            self.session.__exit__(None, None, None)


class AbstractMOGraphQLProvider(ABC, MOGraphQLProvider):
    @property
    @abstractmethod
    def read_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def read_filter_model(self) -> type[BaseModel]:
        raise NotImplementedError

    @property
    @abstractmethod
    def create_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def create_input_model(self) -> type[BaseModel]:
        raise NotImplementedError

    @property
    @abstractmethod
    def update_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def update_input_model(self) -> type[BaseModel]:
        raise NotImplementedError

    def _read_by_filter(self, filter: dict[str, Any]) -> dict[str, Any] | None:
        result = self.read_method(filter=parse_obj_as(self.read_filter_model, filter))
        entity = only(result.objects)
        if entity is None or entity.current is None:
            return None
        current = entity.current
        assert isinstance(current, BaseModel)
        return current.dict()

    def _read_by_uuid(self, uuid: UUID) -> dict[str, Any] | None:
        return self._read_by_filter({"uuids": [str(uuid)]})

    def read(self, id: str, props: dict[str, Any]) -> ReadResult:
        uuid = UUID(id)
        result = self._read_by_uuid(uuid)
        if result is None:
            return ReadResult(None, None)
        return ReadResult(id, result)

    def create(self, props: dict[str, Any]) -> CreateResult:
        needs_validity = "validity" in self.create_input_model.__fields__
        payload = {**props, "validity": DEFAULT_VALIDITY} if needs_validity else props

        result = self.create_method(
            input=parse_obj_as(self.create_input_model, payload)
        )
        return CreateResult(str(result.uuid), props)

    def update(
        self, id: str, _olds: dict[str, Any], props: dict[str, Any]
    ) -> UpdateResult:
        uuid = UUID(id)
        self.update_method(
            input=parse_obj_as(
                self.update_input_model,
                {**props, "uuid": uuid, "validity": DEFAULT_VALIDITY},
            )
        )
        return UpdateResult({**props})
