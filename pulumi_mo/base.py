# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import inspect
from abc import ABC
from abc import abstractmethod
from collections.abc import Callable
from functools import partial
from typing import Any
from typing import cast
from uuid import UUID

from authlib.integrations.httpx_client import OAuth2Client
from more_itertools import only
from pulumi import Config
from pulumi.dynamic import ConfigureRequest
from pulumi.dynamic import CreateResult
from pulumi.dynamic import ReadResult
from pulumi.dynamic import ResourceProvider
from pulumi.dynamic import UpdateResult
from pulumi.dynamic.config import Config as DynamicConfig
from pydantic import BaseModel
from pydantic import parse_obj_as

from .autogenerated_graphql_client.client import GraphQLClient

DEFAULT_VALIDITY = {"from": "1970-01-01T00:00:00Z"}


def create_graphql_client(
    mora_base: str, client_id: str, client_secret: str, auth_server: str | None = None
) -> GraphQLClient:
    auth_server = auth_server or (mora_base + "/auth/")
    auth_realm = "mo"
    timeout = 60
    graphql_version = 25

    oauth_client = OAuth2Client(
        base_url=mora_base,
        client_id=client_id,
        client_secret=client_secret,
        grant_type="client_credentials",
        # TODO: We should take a full token URL instead of hard-coding Keycloak's
        # URL scheme. Let's wait until the legacy clients are removed.
        token_endpoint=f"{auth_server}/realms/{auth_realm}/protocol/openid-connect/token",
        # TODO (https://github.com/lepture/authlib/issues/531): Hack to enable
        # automatic fetching of token on first call, instead of only refreshing.
        token={"expires_at": -1, "access_token": ""},
        timeout=timeout,
    )
    graphql_client = GraphQLClient(
        url=f"{mora_base}/graphql/v{graphql_version}", http_client=oauth_client
    )
    return graphql_client


def create_graphql_client_from_config(config: Config | DynamicConfig) -> GraphQLClient:
    mora_base = config.require("mora_base")
    client_id = config.require("mora_client_id")
    client_secret = config.require("mora_client_secret")
    auth_server = config.get("mora_auth_server")
    return create_graphql_client(mora_base, client_id, client_secret, auth_server)


class MOGraphQLProvider(ResourceProvider):
    session: GraphQLClient

    def configure(self, req: ConfigureRequest) -> None:
        graphql_client = create_graphql_client_from_config(req.config)
        session = graphql_client.__enter__()
        self.session = session

    def __del__(self) -> None:
        if hasattr(self, "session") and self.session:
            self.session.__exit__(None, None, None)


def get_parameter_type(method: Callable, parameter_name: str) -> type[BaseModel]:
    signature = inspect.signature(method)
    parameter = signature.parameters[parameter_name]
    parameter_type = parameter.annotation
    return cast(type[BaseModel], parameter_type)


get_input_model_from_mutator = partial(get_parameter_type, parameter_name="input")
get_filter_model_from_query = partial(get_parameter_type, parameter_name="filter")


class AbstractMOGraphQLProvider(ABC, MOGraphQLProvider):
    @property
    @abstractmethod
    def read_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def create_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def update_method(self) -> Callable:
        raise NotImplementedError

    @property
    @abstractmethod
    def delete_method(self) -> Callable:
        raise NotImplementedError

    def _read_by_filter(self, filter: dict[str, Any]) -> dict[str, Any] | None:
        filter_model = get_filter_model_from_query(self.read_method)
        result = self.read_method(filter=parse_obj_as(filter_model, filter))
        entity = only(result.objects)
        if entity is None or entity.current is None:
            return None
        current = entity.current
        assert isinstance(current, BaseModel)
        return current.dict()

    def _read_by_uuid(self, uuid: UUID) -> dict[str, Any] | None:
        return self._read_by_filter({"uuids": [str(uuid)]})

    def read(self, id: str, props: dict[str, Any]) -> ReadResult:
        uuid = UUID(id)
        result = self._read_by_uuid(uuid)
        if result is None:
            return ReadResult(None, None)
        return ReadResult(id, result)

    def create(self, props: dict[str, Any]) -> CreateResult:
        input_model = get_input_model_from_mutator(self.create_method)
        needs_validity = "validity" in input_model.__fields__
        payload = {**props, "validity": DEFAULT_VALIDITY} if needs_validity else props

        result = self.create_method(input=parse_obj_as(input_model, payload))
        return CreateResult(str(result.uuid), props)

    def update(
        self, id: str, _olds: dict[str, Any], props: dict[str, Any]
    ) -> UpdateResult:
        input_model = get_input_model_from_mutator(self.update_method)
        uuid = UUID(id)
        self.update_method(
            input=parse_obj_as(
                input_model,
                {**props, "uuid": uuid, "validity": DEFAULT_VALIDITY},
            )
        )
        return UpdateResult({**props})

    def delete(self, id: str, props: dict[str, Any]) -> None:
        uuid = UUID(id)
        self.delete_method(uuid=uuid)


class AutoMOGraphQLProvider(AbstractMOGraphQLProvider):
    collection: str

    def get_client_method(self, operation: str) -> Callable:
        return cast(Callable, getattr(self.session, self.collection + "_" + operation))

    @property
    def read_method(self) -> Callable:
        return self.get_client_method("read")

    @property
    def create_method(self) -> Callable:
        return self.get_client_method("create")

    @property
    def update_method(self) -> Callable:
        return self.get_client_method("update")

    @property
    def delete_method(self) -> Callable:
        return self.get_client_method("delete")
